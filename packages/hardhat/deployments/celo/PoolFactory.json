{
  "address": "0x4e51E761707d11012f51E99B266CD195cEBbFa04",
  "abi": [
    {
      "inputs": [],
      "name": "ERC1167FailedCreateClone",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "strategy",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "pool",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "owner",
              "type": "address"
            },
            {
              "internalType": "address[]",
              "name": "admins",
              "type": "address[]"
            },
            {
              "internalType": "address",
              "name": "allocationToken",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "distributionToken",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "maxAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint64[]",
              "name": "timestamps",
              "type": "uint64[]"
            },
            {
              "internalType": "string",
              "name": "metadataURI",
              "type": "string"
            }
          ],
          "indexed": false,
          "internalType": "struct PoolConfig",
          "name": "config",
          "type": "tuple"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "Created",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "implementation",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "owner",
              "type": "address"
            },
            {
              "internalType": "address[]",
              "name": "admins",
              "type": "address[]"
            },
            {
              "internalType": "address",
              "name": "allocationToken",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "distributionToken",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "maxAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint64[]",
              "name": "timestamps",
              "type": "uint64[]"
            },
            {
              "internalType": "string",
              "name": "metadataURI",
              "type": "string"
            }
          ],
          "internalType": "struct PoolConfig",
          "name": "config",
          "type": "tuple"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "deploy",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x3738f4e37d34ed166348186ffea49eaae18bd746d2ca7bf80fe3b2b84c58d09b",
  "receipt": {
    "to": null,
    "from": "0x1473d1559B7469ED2B9A51790b7177a74958c5bB",
    "contractAddress": "0x4e51E761707d11012f51E99B266CD195cEBbFa04",
    "transactionIndex": 6,
    "gasUsed": "317363",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x00ad100e86c4a8170fd722fe6fb5fd8869b9611047ffac49e655231479dad6e7",
    "transactionHash": "0x3738f4e37d34ed166348186ffea49eaae18bd746d2ca7bf80fe3b2b84c58d09b",
    "logs": [],
    "blockNumber": 40783132,
    "cumulativeGasUsed": "668878",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 2,
  "solcInputHash": "3f17ded319fb991c02fd3657fb77494e",
  "metadata": "{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"ERC1167FailedCreateClone\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"admins\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"allocationToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"distributionToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint64[]\",\"name\":\"timestamps\",\"type\":\"uint64[]\"},{\"internalType\":\"string\",\"name\":\"metadataURI\",\"type\":\"string\"}],\"indexed\":false,\"internalType\":\"struct PoolConfig\",\"name\":\"config\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Created\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"admins\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"allocationToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"distributionToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint64[]\",\"name\":\"timestamps\",\"type\":\"uint64[]\"},{\"internalType\":\"string\",\"name\":\"metadataURI\",\"type\":\"string\"}],\"internalType\":\"struct PoolConfig\",\"name\":\"config\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"deploy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"ERC1167FailedCreateClone()\":[{\"details\":\"A clone instance deployment failed.\"}]},\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/PoolFactory.sol\":\"PoolFactory\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/proxy/Clones.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/Clones.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n */\\nlibrary Clones {\\n    /**\\n     * @dev A clone instance deployment failed.\\n     */\\n    error ERC1167FailedCreateClone();\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create(0, 0x09, 0x37)\\n        }\\n        if (instance == address(0)) {\\n            revert ERC1167FailedCreateClone();\\n        }\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create2(0, 0x09, 0x37, salt)\\n        }\\n        if (instance == address(0)) {\\n            revert ERC1167FailedCreateClone();\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(add(ptr, 0x38), deployer)\\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\\n            mstore(add(ptr, 0x14), implementation)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\\n            mstore(add(ptr, 0x58), salt)\\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\\n            predicted := keccak256(add(ptr, 0x43), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt\\n    ) internal view returns (address predicted) {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\",\"keccak256\":\"0xd18408af8a91bedb3d56343eeb9b30eb852e6dea93a5e2d5c6db9ca4cb905155\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\",\"keccak256\":\"0xc6a8ff0ea489379b61faa647490411b80102578440ab9d84e9a957cc12164e70\",\"license\":\"MIT\"},\"contracts/Pool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\nstruct PoolConfig {\\r\\n    address owner;\\r\\n    address[] admins;\\r\\n    address allocationToken;\\r\\n    address distributionToken;\\r\\n    uint256 maxAmount;\\r\\n    uint64[] timestamps;\\r\\n    string metadataURI;\\r\\n}\\r\\n\\r\\ninterface IPool {\\r\\n    enum Status {\\r\\n        pending,\\r\\n        approved,\\r\\n        rejected\\r\\n    }\\r\\n\\r\\n    struct Registration {\\r\\n        Status status;\\r\\n        address owner;\\r\\n        string metadataURI;\\r\\n        bytes data; // Data can contain information that can be accessed later\\r\\n    }\\r\\n\\r\\n    function schema() external view returns (string memory);\\r\\n\\r\\n    event Deployed(string name, address indexed owner, string schema, string metadataURI);\\r\\n    event Allocate(address indexed from, address indexed to, uint256 amount, address token, bytes data);\\r\\n    event Register(address indexed project, address indexed owner, string metadataURI, bytes data);\\r\\n    event Review(address indexed project, uint8 status, address indexed approver, string metadataURI, bytes data);\\r\\n    event Update(address indexed project, address indexed updater, string metadataURI, bytes data);\\r\\n    event Configure(address indexed updater, PoolConfig config);\\r\\n\\r\\n    function initialize(PoolConfig memory config, bytes memory data) external;\\r\\n    function configure(PoolConfig memory config) external;\\r\\n    function register(address project, string memory metadataURI, bytes memory data) external;\\r\\n    function update(address project, string memory metadataURI, bytes memory data) external;\\r\\n    function review(address project, uint8 status, string memory metadataURI, bytes memory data) external;\\r\\n    function allocate(address[] memory recipients, uint256[] memory amounts, address token, bytes[] memory data)\\r\\n        external;\\r\\n    function distribute(address[] memory recipients, uint256[] memory amounts, address token, bytes[] memory data)\\r\\n        external;\\r\\n}\\r\\n\\r\\n/*\\r\\nTypes of Pools:\\r\\nDirectGrants - pool manager transfer funds directly to projects\\r\\nRetroFunding - selected voters vote on projects and pool gets distributed based on the votes\\r\\nQuadraticFunding - people vote with money tokens and get matching funds from the pool based on quadratic formula\\r\\nDedicatedDomainAllocation - selected panel of domain experts decide what projects receive matching funds\\r\\nRFPs\\r\\nBounties\\r\\nCrowdfunding\\r\\n*/\\r\\ncontract Pool is IPool {\\r\\n    bool private _initialized;\\r\\n    PoolConfig public config;\\r\\n    string public schema;\\r\\n\\r\\n    mapping(address => Registration) public registrations;\\r\\n\\r\\n    /**\\r\\n     * @param _name Name of the Pool Strategy\\r\\n     * @param _schema Schema of the Pool (uint256 param, string anotherParam) - can be used for passing custom data\\r\\n     * @param _metadataURI Metadata URI of the Pool (title, description, etc.)\\r\\n     */\\r\\n    constructor(string memory _name, string memory _schema, string memory _metadataURI) {\\r\\n        // Emit an event for the Indexer so Pools can be created with this Strategy\\r\\n        emit Deployed(_name, msg.sender, _schema, _metadataURI);\\r\\n        schema = _schema;\\r\\n    }\\r\\n\\r\\n    function initialize(PoolConfig memory _config, bytes memory data) public virtual {\\r\\n        require(!_initialized, \\\"Already initialized\\\");\\r\\n        _initialized = true;\\r\\n        config = _config;\\r\\n    }\\r\\n\\r\\n    function _configure(PoolConfig memory _config) internal virtual {\\r\\n        // Logic for updating the Pool handled in calling contract\\r\\n        config = _config;\\r\\n        emit Configure(msg.sender, _config);\\r\\n    }\\r\\n\\r\\n    // MetadataURI contain details about project application\\r\\n    function _register(address project, string memory _metadataURI, bytes memory data) internal {\\r\\n        require(registrations[project].owner == address(0), \\\"Already registered\\\");\\r\\n        registrations[project] = Registration(Status.pending, msg.sender, _metadataURI, data);\\r\\n        emit Register(project, msg.sender, _metadataURI, data);\\r\\n    }\\r\\n\\r\\n    function _review(address project, uint8 status, string memory _metadataURI, bytes memory data) internal {\\r\\n        Registration storage registration = registrations[project];\\r\\n        registration.status = Status(status);\\r\\n        // MetadataURI can contain information about review, or potential rejection reason\\r\\n        emit Review(project, status, msg.sender, _metadataURI, data);\\r\\n    }\\r\\n\\r\\n    function _update(address project, string memory _metadataURI, bytes memory data) internal {\\r\\n        require(registrations[project].owner == msg.sender, \\\"Must be owner to update\\\");\\r\\n        require(registrations[project].status != Status.approved, \\\"Already approved\\\");\\r\\n        registrations[project].metadataURI = _metadataURI;\\r\\n        registrations[project].data = data;\\r\\n        emit Update(project, msg.sender, _metadataURI, data);\\r\\n    }\\r\\n\\r\\n    // Allocate tokens to recipients (transfers tokens from caller to recipients)\\r\\n    // This can be used to transfer tokens to projects, or the contract itself to fund with matching funds for example\\r\\n    function _allocate(address[] memory recipients, uint256[] memory amounts, address token, bytes[] memory data)\\r\\n        internal\\r\\n    {\\r\\n        uint256 length = recipients.length;\\r\\n        require(length > 0 && length == amounts.length, \\\"Mismatched lengths\\\");\\r\\n\\r\\n        for (uint256 i = 0; i < length; i++) {\\r\\n            bytes memory _data = i < data.length ? data[i] : bytes(\\\"\\\");\\r\\n            require(recipients[i] != address(0), \\\"Recipient is zero address\\\");\\r\\n            require(amounts[i] > 0, \\\"Amount is zero\\\");\\r\\n            _beforeAllocate(recipients[i], amounts[i], token, _data);\\r\\n            IERC20(token).transferFrom(msg.sender, recipients[i], amounts[i]);\\r\\n            emit Allocate(msg.sender, recipients[i], amounts[i], token, _data);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // Distribute tokens to recipients (transfers tokens from the contract to recipients)\\r\\n    // Can be used to distribute matching funds to projects\\r\\n    function _distribute(address[] memory recipients, uint256[] memory amounts, address token, bytes[] memory data)\\r\\n        internal\\r\\n    {\\r\\n        uint256 length = recipients.length;\\r\\n        require(length > 0 && length == amounts.length, \\\"Mismatched lengths\\\");\\r\\n\\r\\n        for (uint256 i = 0; i < length; i++) {\\r\\n            bytes memory _data = i < data.length ? data[i] : bytes(\\\"\\\");\\r\\n            require(recipients[i] != address(0), \\\"Recipient is zero address\\\");\\r\\n            require(\\r\\n                amounts[i] > 0 && amounts[i] <= IERC20(token).balanceOf(address(this)),\\r\\n                \\\"Amount is zero or exceeds balance\\\"\\r\\n            );\\r\\n            _beforeDistribute(recipients[i], amounts[i], token, _data);\\r\\n            IERC20(token).transfer(recipients[i], amounts[i]);\\r\\n            emit Allocate(address(this), recipients[i], amounts[i], token, _data);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _beforeAllocate(address recipient, uint256 amount, address token, bytes memory data) internal virtual {}\\r\\n    function _beforeDistribute(address recipient, uint256 amount, address token, bytes memory data) internal virtual {}\\r\\n\\r\\n    function configure(PoolConfig memory _config) external virtual override {\\r\\n        _configure(_config);\\r\\n    }\\r\\n\\r\\n    function register(address project, string memory metadataURI, bytes memory data) external virtual override {\\r\\n        _register(project, metadataURI, data);\\r\\n    }\\r\\n\\r\\n    function update(address project, string memory metadataURI, bytes memory data) external virtual override {\\r\\n        _update(project, metadataURI, data);\\r\\n    }\\r\\n\\r\\n    function review(address project, uint8 status, string memory metadataURI, bytes memory data)\\r\\n        external\\r\\n        virtual\\r\\n        override\\r\\n    {\\r\\n        _review(project, status, metadataURI, data);\\r\\n    }\\r\\n\\r\\n    function allocate(address[] memory recipients, uint256[] memory amounts, address token, bytes[] memory data)\\r\\n        external\\r\\n        virtual\\r\\n        override\\r\\n    {\\r\\n        _allocate(recipients, amounts, token, data);\\r\\n    }\\r\\n\\r\\n    function distribute(address[] memory recipients, uint256[] memory amounts, address token, bytes[] memory data)\\r\\n        external\\r\\n        virtual\\r\\n        override\\r\\n    {\\r\\n        _distribute(recipients, amounts, token, data);\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x2ffd1dd34f247ac3e376c48e6aa27deef451c505a92df6b704a336f96e90a3cd\",\"license\":\"MIT\"},\"contracts/PoolFactory.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/proxy/Clones.sol\\\";\\r\\nimport { IPool, Pool, PoolConfig } from \\\"./Pool.sol\\\";\\r\\n\\r\\ncontract PoolFactory {\\r\\n    event Created(address indexed strategy, address indexed pool, PoolConfig config,  bytes data);\\r\\n\\r\\n    function deploy(\\r\\n        address implementation,\\r\\n        PoolConfig calldata config,\\r\\n        bytes calldata data\\r\\n    ) external returns (address) {\\r\\n        address poolAddress = Clones.clone(implementation);\\r\\n        IPool(poolAddress).initialize(config, data);\\r\\n        emit Created(implementation, poolAddress, config,  data);\\r\\n        return poolAddress;\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xbb4039b34671079eeb19e687a43c31165dc6030ef6dbbfb7dbc5f109b92118bc\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b506104c7806100206000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c80633938e38c14610030575b600080fd5b61004361003e3660046101b1565b61005f565b6040516001600160a01b03909116815260200160405180910390f35b60008061006b86610128565b60405163ab21f50760e01b81529091506001600160a01b0382169063ab21f5079061009e9088908890889060040161036a565b600060405180830381600087803b1580156100b857600080fd5b505af11580156100cc573d6000803e3d6000fd5b50505050806001600160a01b0316866001600160a01b03167f744457ffa91321191756df789f7db35659c3bdf903b8872f8c891b1cd884044d8787876040516101179392919061036a565b60405180910390a395945050505050565b6000763d602d80600a3d3981f3363d3d373d3d3d363d730000008260601b60e81c176000526e5af43d82803e903d91602b57fd5bf38260781b17602052603760096000f090506001600160a01b038116610195576040516330be1a3d60e21b815260040160405180910390fd5b919050565b80356001600160a01b038116811461019557600080fd5b600080600080606085870312156101c757600080fd5b6101d08561019a565b9350602085013567ffffffffffffffff808211156101ed57600080fd5b9086019060e0828903121561020157600080fd5b9093506040860135908082111561021757600080fd5b818701915087601f83011261022b57600080fd5b81358181111561023a57600080fd5b88602082850101111561024c57600080fd5b95989497505060200194505050565b6000808335601e1984360301811261027257600080fd5b830160208101925035905067ffffffffffffffff81111561029257600080fd5b8060051b36038213156102a457600080fd5b9250929050565b818352600060208085019450826000805b868110156102ef57823567ffffffffffffffff81168082146102dc578384fd5b89525096830196918301916001016102bc565b50959695505050505050565b6000808335601e1984360301811261031257600080fd5b830160208101925035905067ffffffffffffffff81111561033257600080fd5b8036038213156102a457600080fd5b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b60408152600061012082016001600160a01b03806103878861019a565b166040850152602061039b8189018961025b565b60e06060880152938490529260009061014087015b818310156103d757846103c28761019a565b168152948301946001929092019183016103b0565b6103e360408c0161019a565b6001600160a01b03811660808a0152955061040060608c0161019a565b6001600160a01b03811660a08a0152955060808b013560c089015261042860a08c018c61025b565b96509450603f199250828882030160e08901526104468187876102ab565b9550505061045760c08a018a6102fb565b9350818786030161010088015261046f858583610341565b94505050848303818601525050610487818587610341565b969550505050505056fea26469706673582212205bd61107750ca76ddf3a83ee7c5c050e36611fbaea71ef1497ece94bdf5a426564736f6c63430008140033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061002b5760003560e01c80633938e38c14610030575b600080fd5b61004361003e3660046101b1565b61005f565b6040516001600160a01b03909116815260200160405180910390f35b60008061006b86610128565b60405163ab21f50760e01b81529091506001600160a01b0382169063ab21f5079061009e9088908890889060040161036a565b600060405180830381600087803b1580156100b857600080fd5b505af11580156100cc573d6000803e3d6000fd5b50505050806001600160a01b0316866001600160a01b03167f744457ffa91321191756df789f7db35659c3bdf903b8872f8c891b1cd884044d8787876040516101179392919061036a565b60405180910390a395945050505050565b6000763d602d80600a3d3981f3363d3d373d3d3d363d730000008260601b60e81c176000526e5af43d82803e903d91602b57fd5bf38260781b17602052603760096000f090506001600160a01b038116610195576040516330be1a3d60e21b815260040160405180910390fd5b919050565b80356001600160a01b038116811461019557600080fd5b600080600080606085870312156101c757600080fd5b6101d08561019a565b9350602085013567ffffffffffffffff808211156101ed57600080fd5b9086019060e0828903121561020157600080fd5b9093506040860135908082111561021757600080fd5b818701915087601f83011261022b57600080fd5b81358181111561023a57600080fd5b88602082850101111561024c57600080fd5b95989497505060200194505050565b6000808335601e1984360301811261027257600080fd5b830160208101925035905067ffffffffffffffff81111561029257600080fd5b8060051b36038213156102a457600080fd5b9250929050565b818352600060208085019450826000805b868110156102ef57823567ffffffffffffffff81168082146102dc578384fd5b89525096830196918301916001016102bc565b50959695505050505050565b6000808335601e1984360301811261031257600080fd5b830160208101925035905067ffffffffffffffff81111561033257600080fd5b8036038213156102a457600080fd5b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b60408152600061012082016001600160a01b03806103878861019a565b166040850152602061039b8189018961025b565b60e06060880152938490529260009061014087015b818310156103d757846103c28761019a565b168152948301946001929092019183016103b0565b6103e360408c0161019a565b6001600160a01b03811660808a0152955061040060608c0161019a565b6001600160a01b03811660a08a0152955060808b013560c089015261042860a08c018c61025b565b96509450603f199250828882030160e08901526104468187876102ab565b9550505061045760c08a018a6102fb565b9350818786030161010088015261046f858583610341565b94505050848303818601525050610487818587610341565b969550505050505056fea26469706673582212205bd61107750ca76ddf3a83ee7c5c050e36611fbaea71ef1497ece94bdf5a426564736f6c63430008140033",
  "devdoc": {
    "errors": {
      "ERC1167FailedCreateClone()": [
        {
          "details": "A clone instance deployment failed."
        }
      ]
    },
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}